{
    "summary": "The code prepares the environment, generates tasks, and logs interactions with GPT-4. It handles various actions, checks for completion, queries GPT-4 upon task completion, logs relevant information, manages errors, and processes, logs, and updates actions while managing errors and documentation; autonomous exploration ends upon reaching max rounds or in case of unexpected events, displaying a yellow or red message with doc count and success status.",
    "details": [
        {
            "comment": "The code imports necessary libraries and defines arguments for executing the autonomous exploration script. It then loads configuration files, retrieves input from the user for target app name, creates directories if they don't exist, and prepares the environment for running the script.",
            "location": "\"/media/root/Toshiba XG3/works/AppAgent/docs/src/scripts/self_explorer.py\":0-37",
            "content": "import argparse\nimport ast\nimport datetime\nimport json\nimport os\nimport re\nimport sys\nimport time\nimport prompts\nfrom config import load_config\nfrom and_controller import list_all_devices, AndroidController, traverse_tree\nfrom model import ask_gpt4v, parse_explore_rsp, parse_reflect_rsp\nfrom utils import print_with_color, draw_bbox_multi, encode_image\narg_desc = \"AppAgent - Autonomous Exploration\"\nparser = argparse.ArgumentParser(formatter_class=argparse.RawDescriptionHelpFormatter, description=arg_desc)\nparser.add_argument(\"--app\")\nparser.add_argument(\"--root_dir\", default=\"./\")\nargs = vars(parser.parse_args())\nconfigs = load_config()\napp = args[\"app\"]\nroot_dir = args[\"root_dir\"]\nif not app:\n    print_with_color(\"What is the name of the target app?\", \"blue\")\n    app = input()\n    app = app.replace(\" \", \"\")\nwork_dir = os.path.join(root_dir, \"apps\")\nif not os.path.exists(work_dir):\n    os.mkdir(work_dir)\nwork_dir = os.path.join(work_dir, app)\nif not os.path.exists(work_dir):\n    os.mkdir(work_dir)\ndemo_dir = os.path.join(work_dir, \"demos\")"
        },
        {
            "comment": "Checking if demo directory exists and creating it, then generating a task name and directory. Creating directories for auto_docs, log files, listing devices, and assigning one device based on the number of devices found.",
            "location": "\"/media/root/Toshiba XG3/works/AppAgent/docs/src/scripts/self_explorer.py\":38-62",
            "content": "if not os.path.exists(demo_dir):\n    os.mkdir(demo_dir)\ndemo_timestamp = int(time.time())\ntask_name = datetime.datetime.fromtimestamp(demo_timestamp).strftime(\"self_explore_%Y-%m-%d_%H-%M-%S\")\ntask_dir = os.path.join(demo_dir, task_name)\nos.mkdir(task_dir)\ndocs_dir = os.path.join(work_dir, \"auto_docs\")\nif not os.path.exists(docs_dir):\n    os.mkdir(docs_dir)\nexplore_log_path = os.path.join(task_dir, f\"log_explore_{task_name}.txt\")\nreflect_log_path = os.path.join(task_dir, f\"log_reflect_{task_name}.txt\")\ndevice_list = list_all_devices()\nif not device_list:\n    print_with_color(\"ERROR: No device found!\", \"red\")\n    sys.exit()\nprint_with_color(f\"List of devices attached:\\n{str(device_list)}\", \"yellow\")\nif len(device_list) == 1:\n    device = device_list[0]\n    print_with_color(f\"Device selected: {device}\", \"yellow\")\nelse:\n    print_with_color(\"Please choose the Android device to start demo by entering its ID:\", \"blue\")\n    device = input()\ncontroller = AndroidController(device)\nwidth, height = controller.get_device_size()"
        },
        {
            "comment": "Checks if width and height are provided. If not, displays an error message and exits. Otherwise, prints device resolution and prompts for task description. Starts a loop to complete the task in multiple rounds until reaching MAX_ROUNDS.",
            "location": "\"/media/root/Toshiba XG3/works/AppAgent/docs/src/scripts/self_explorer.py\":63-90",
            "content": "if not width and not height:\n    print_with_color(\"ERROR: Invalid device size!\", \"red\")\n    sys.exit()\nprint_with_color(f\"Screen resolution of {device}: {width}x{height}\", \"yellow\")\nprint_with_color(\"Please enter the description of the task you want me to complete in a few sentences:\", \"blue\")\ntask_desc = input()\nround_count = 0\ndoc_count = 0\nuseless_list = set()\nlast_act = \"None\"\ntask_complete = False\nwhile round_count < configs[\"MAX_ROUNDS\"]:\n    round_count += 1\n    print_with_color(f\"Round {round_count}\", \"yellow\")\n    screenshot_before = controller.get_screenshot(f\"{round_count}_before\", task_dir)\n    xml_path = controller.get_xml(f\"{round_count}\", task_dir)\n    if screenshot_before == \"ERROR\" or xml_path == \"ERROR\":\n        break\n    clickable_list = []\n    focusable_list = []\n    traverse_tree(xml_path, clickable_list, \"clickable\", True)\n    traverse_tree(xml_path, focusable_list, \"focusable\", True)\n    elem_list = []\n    for elem in clickable_list:\n        if elem.uid in useless_list:\n            continue"
        },
        {
            "comment": "This code finds focusable elements on the screen, checks if they are close to any clickable elements, and adds them to a list. It then draws bounding boxes around these elements in an image and generates a task prompt with the image encoded as base64.",
            "location": "\"/media/root/Toshiba XG3/works/AppAgent/docs/src/scripts/self_explorer.py\":91-112",
            "content": "        elem_list.append(elem)\n    for elem in focusable_list:\n        if elem.uid in useless_list:\n            continue\n        bbox = elem.bbox\n        center = (bbox[0][0] + bbox[1][0]) // 2, (bbox[0][1] + bbox[1][1]) // 2\n        close = False\n        for e in clickable_list:\n            bbox = e.bbox\n            center_ = (bbox[0][0] + bbox[1][0]) // 2, (bbox[0][1] + bbox[1][1]) // 2\n            dist = (abs(center[0] - center_[0]) ** 2 + abs(center[1] - center_[1]) ** 2) ** 0.5\n            if dist <= configs[\"MIN_DIST\"]:\n                close = True\n                break\n        if not close:\n            elem_list.append(elem)\n    draw_bbox_multi(screenshot_before, os.path.join(task_dir, f\"{round_count}_before_labeled.png\"), elem_list,\n                    dark_mode=configs[\"DARK_MODE\"])\n    prompt = re.sub(r\"<task_description>\", task_desc, prompts.self_explore_task_template)\n    prompt = re.sub(r\"<last_act>\", last_act, prompt)\n    base64_img_before = encode_image(os.path.join(task_dir, f\"{round_count}_before_labeled.png\"))"
        },
        {
            "comment": "This code is sending a prompt to GPT-4 and receiving a response. It then logs the step, prompt, image, and response before parsing the response and checking if it's a \"FINISH\" command or a \"tap\" action.",
            "location": "\"/media/root/Toshiba XG3/works/AppAgent/docs/src/scripts/self_explorer.py\":113-144",
            "content": "    content = [\n        {\n            \"type\": \"text\",\n            \"text\": prompt\n        },\n        {\n            \"type\": \"image_url\",\n            \"image_url\": {\n                \"url\": f\"data:image/jpeg;base64,{base64_img_before}\"\n            }\n        }\n    ]\n    print_with_color(\"Thinking about what to do in the next step...\", \"yellow\")\n    rsp = ask_gpt4v(content)\n    if \"error\" not in rsp:\n        with open(explore_log_path, \"a\") as logfile:\n            log_item = {\"step\": round_count, \"prompt\": prompt, \"image\": f\"{round_count}_before_labeled.png\",\n                        \"response\": rsp}\n            logfile.write(json.dumps(log_item) + \"\\n\")\n        res = parse_explore_rsp(rsp)\n        act_name = res[0]\n        last_act = res[-1]\n        res = res[:-1]\n        if act_name == \"FINISH\":\n            task_complete = True\n            break\n        if act_name == \"tap\":\n            _, area = res\n            tl, br = elem_list[area - 1].bbox\n            x, y = (tl[0] + br[0]) // 2, (tl[1] + br[1]) // 2\n            ret = controller.tap(x, y)"
        },
        {
            "comment": "This code handles different actions (tap, text, long_press, swipe) performed by the script. It checks if the execution of each action fails and prints an error message with color formatting in case of failure.",
            "location": "\"/media/root/Toshiba XG3/works/AppAgent/docs/src/scripts/self_explorer.py\":145-168",
            "content": "            if ret == \"ERROR\":\n                print_with_color(\"ERROR: tap execution failed\", \"red\")\n                break\n        elif act_name == \"text\":\n            _, input_str = res\n            ret = controller.text(input_str)\n            if ret == \"ERROR\":\n                print_with_color(\"ERROR: text execution failed\", \"red\")\n                break\n        elif act_name == \"long_press\":\n            _, area = res\n            tl, br = elem_list[area - 1].bbox\n            x, y = (tl[0] + br[0]) // 2, (tl[1] + br[1]) // 2\n            ret = controller.long_press(x, y)\n            if ret == \"ERROR\":\n                print_with_color(\"ERROR: long press execution failed\", \"red\")\n                break\n        elif act_name == \"swipe\":\n            _, area, swipe_dir, dist = res\n            tl, br = elem_list[area - 1].bbox\n            x, y = (tl[0] + br[0]) // 2, (tl[1] + br[1]) // 2\n            ret = controller.swipe(x, y, swipe_dir, dist)\n            if ret == \"ERROR\":\n                print_with_color(\"ERROR: swipe execution failed\", \"red\")"
        },
        {
            "comment": "Checking if task is complete and breaks loop",
            "location": "\"/media/root/Toshiba XG3/works/AppAgent/docs/src/scripts/self_explorer.py\":169-194",
            "content": "                break\n        else:\n            break\n        time.sleep(configs[\"REQUEST_INTERVAL\"])\n    else:\n        print_with_color(rsp[\"error\"][\"message\"], \"red\")\n        break\n    screenshot_after = controller.get_screenshot(f\"{round_count}_after\", task_dir)\n    if screenshot_after == \"ERROR\":\n        break\n    draw_bbox_multi(screenshot_after, os.path.join(task_dir, f\"{round_count}_after_labeled.png\"), elem_list,\n                    dark_mode=configs[\"DARK_MODE\"])\n    base64_img_after = encode_image(os.path.join(task_dir, f\"{round_count}_after_labeled.png\"))\n    if act_name == \"tap\":\n        prompt = re.sub(r\"<action>\", \"tapping\", prompts.self_explore_reflect_template)\n    elif act_name == \"text\":\n        continue\n    elif act_name == \"long_press\":\n        prompt = re.sub(r\"<action>\", \"long pressing\", prompts.self_explore_reflect_template)\n    elif act_name == \"swipe\":\n        swipe_dir = res[2]\n        if swipe_dir == \"up\" or swipe_dir == \"down\":\n            act_name = \"v_swipe\"\n        elif swipe_dir == \"left\" or swipe_dir == \"right\":"
        },
        {
            "comment": "Code is preparing a message to ask GPT-4 about a previous action. It replaces placeholders in the prompt with appropriate values and sends it to GPT-4 for response. If there's no error in the response, it logs relevant information into reflect_log_path.",
            "location": "\"/media/root/Toshiba XG3/works/AppAgent/docs/src/scripts/self_explorer.py\":195-227",
            "content": "            act_name = \"h_swipe\"\n        prompt = re.sub(r\"<action>\", \"swiping\", prompts.self_explore_reflect_template)\n    else:\n        print_with_color(\"ERROR: Undefined act!\", \"red\")\n        break\n    prompt = re.sub(r\"<ui_element>\", str(area), prompt)\n    prompt = re.sub(r\"<task_desc>\", task_desc, prompt)\n    prompt = re.sub(r\"<last_act>\", last_act, prompt)\n    content = [\n        {\n            \"type\": \"text\",\n            \"text\": prompt\n        },\n        {\n            \"type\": \"image_url\",\n            \"image_url\": {\n                \"url\": f\"data:image/jpeg;base64,{base64_img_before}\"\n            }\n        },\n        {\n            \"type\": \"image_url\",\n            \"image_url\": {\n                \"url\": f\"data:image/jpeg;base64,{base64_img_after}\"\n            }\n        }\n    ]\n    print_with_color(\"Reflecting on my previous action...\", \"yellow\")\n    rsp = ask_gpt4v(content)\n    if \"error\" not in rsp:\n        resource_id = elem_list[int(area) - 1].uid\n        with open(reflect_log_path, \"a\") as logfile:\n            "
        },
        {
            "comment": "Writing log item to file\nParses response and makes decision\nHandles \"ERROR\", \"INEFFECTIVE\", and other decisions\nIf \"BACK\" or \"CONTINUE\", adds resource_id to useless list, sets last_act to \"None\", and executes back action if necessary\nDocs processing begins",
            "location": "\"/media/root/Toshiba XG3/works/AppAgent/docs/src/scripts/self_explorer.py\":227-248",
            "content": "log_item = {\"step\": round_count, \"prompt\": prompt, \"image_before\": f\"{round_count}_before_labeled.png\",\n                        \"image_after\": f\"{round_count}_after.png\", \"response\": rsp}\n            logfile.write(json.dumps(log_item) + \"\\n\")\n        res = parse_reflect_rsp(rsp)\n        decision = res[0]\n        if decision == \"ERROR\":\n            break\n        if decision == \"INEFFECTIVE\":\n            useless_list.add(resource_id)\n            last_act = \"None\"\n        elif decision == \"BACK\" or decision == \"CONTINUE\" or decision == \"SUCCESS\":\n            if decision == \"BACK\" or decision == \"CONTINUE\":\n                useless_list.add(resource_id)\n                last_act = \"None\"\n                if decision == \"BACK\":\n                    ret = controller.back()\n                    if ret == \"ERROR\":\n                        print_with_color(\"ERROR: back execution failed\", \"red\")\n                        break\n            doc = res[-1]\n            doc_name = resource_id + \".txt\"\n            doc_path = os.path.join(docs_dir, doc_name)"
        },
        {
            "comment": "If file exists, read its content, and if the action's documentation already exists, print a message and continue. Otherwise, create an empty dictionary for the document content, add the current action's documentation, save it to file, increment documentation count, and print a success message. If there is an undefined decision or error in response, print an error message and break the loop. After each task, sleep for the specified request interval.",
            "location": "\"/media/root/Toshiba XG3/works/AppAgent/docs/src/scripts/self_explorer.py\":249-275",
            "content": "            if os.path.exists(doc_path):\n                doc_content = ast.literal_eval(open(doc_path).read())\n                if doc_content[act_name]:\n                    print_with_color(f\"Documentation for the element {resource_id} already exists.\", \"yellow\")\n                    continue\n            else:\n                doc_content = {\n                    \"tap\": \"\",\n                    \"text\": \"\",\n                    \"v_swipe\": \"\",\n                    \"h_swipe\": \"\",\n                    \"long_press\": \"\"\n                }\n            doc_content[act_name] = doc\n            with open(doc_path, \"w\") as outfile:\n                outfile.write(str(doc_content))\n            doc_count += 1\n            print_with_color(f\"Documentation generated and saved to {doc_path}\", \"yellow\")\n        else:\n            print_with_color(f\"ERROR: Undefined decision! {decision}\", \"red\")\n            break\n    else:\n        print_with_color(rsp[\"error\"][\"message\"], \"red\")\n        break\n    time.sleep(configs[\"REQUEST_INTERVAL\"])\nif task_complete:"
        },
        {
            "comment": "Autonomous exploration ended. Yellow message if max rounds reached, red if unexpected, displays doc count and success status.",
            "location": "\"/media/root/Toshiba XG3/works/AppAgent/docs/src/scripts/self_explorer.py\":276-281",
            "content": "    print_with_color(f\"Autonomous exploration completed successfully. {doc_count} docs generated.\", \"yellow\")\nelif round_count == configs[\"MAX_ROUNDS\"]:\n    print_with_color(f\"Autonomous exploration finished due to reaching max rounds. {doc_count} docs generated.\",\n                     \"yellow\")\nelse:\n    print_with_color(f\"Autonomous exploration finished unexpectedly. {doc_count} docs generated.\", \"red\")"
        }
    ]
}